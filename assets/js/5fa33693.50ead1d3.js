"use strict";(self.webpackChunkoc_studio_docs=self.webpackChunkoc_studio_docs||[]).push([[7849],{363:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return a},default:function(){return u},frontMatter:function(){return i},metadata:function(){return r},toc:function(){return h}});var s=t(5893),o=t(1151);const i={title:"Channels",sidebar_label:"Channels"},a=void 0,r={id:"channels/channels",title:"Channels",description:"What are channels?",source:"@site/docs/channels/channels.md",sourceDirName:"channels",slug:"/channels/",permalink:"/docs/channels/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Channels",sidebar_label:"Channels"},sidebar:"docs",previous:{title:"Run on AWS",permalink:"/docs/infrastructure/infrastructure-aws"},next:{title:"AWS Lex (V2) Channel",permalink:"/docs/channels/aws-lex"}},c={},h=[{value:"What are channels?",id:"what-are-channels",level:2},{value:"Text vs Voice",id:"text-vs-voice",level:2},{value:"Custom Channels",id:"custom-channels",level:2}];function l(e){const n={a:"a",admonition:"admonition",h2:"h2",p:"p",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"what-are-channels",children:"What are channels?"}),"\n",(0,s.jsx)(n.p,{children:"Channels are avenues with which users can interact with the intelligent voice assistant on. They can be text input based channels like a chat widget, Slack, Facebook Messenger, etc. or they can be voice input based channels like telephony and smart speakers."}),"\n",(0,s.jsx)(n.h2,{id:"text-vs-voice",children:"Text vs Voice"}),"\n",(0,s.jsx)(n.p,{children:"From a technological perspective, the biggest difference between text and voice channels is the need for speech to text and text to speech bookending the other components of the stack. This causes them to be slightly more expensive on a per interaction basis from text channels."}),"\n",(0,s.jsx)(n.p,{children:"While all channels support the most basic user experience of user request and application response, there are many things to consider from a design perspective. On text channels users tend to be more terse and leverage emojis while on voice channels they may be more verbose to make sure you account for both in your model. Some text channels support rich responses that contain GUI elements such as lists and suggestion chips which can enhance the user experience however voice channels typically do not (smart speakers with screens do). Due to this, when designing this multi-channel multi-modal experiences it is recommended to practice a voice first methodology which prioritizes a focus on ensuring functionality for the most basic user experience without a GUI."}),"\n",(0,s.jsx)(n.p,{children:"From a user experience design perspective, there are many things to consider. While all channels support basic user request, application response interactions, from a design perspective there are many things to consider. On text based channels users tend to be more terse and leverage emojis so make sure you account for these in your model. Depending on the text based channel, adding rich responses with GUI elements and suggestion chips will enhance the user experience. On voice based channels,"}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"Not all NLUs support emoji \u2639\ufe0f"})}),"\n",(0,s.jsx)(n.h2,{id:"custom-channels",children:"Custom Channels"}),"\n",(0,s.jsxs)(n.p,{children:["You can also build custom channels to integrate with existing/new chat widgets, web applications, or customer support software.  Building a custom channel will require you to host the assistant and modify it's runtime environment.  More information can be found ",(0,s.jsx)(n.a,{href:"../development/channels#custom-channels",children:"here"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1151:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return a}});var s=t(7294);const o={},i=s.createContext(o);function a(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);