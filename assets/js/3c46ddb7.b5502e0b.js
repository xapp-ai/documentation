"use strict";(self.webpackChunkoc_studio_docs=self.webpackChunkoc_studio_docs||[]).push([[2716],{4511:function(e,t,n){n.r(t),n.d(t,{assets:function(){return a},contentTitle:function(){return i},default:function(){return u},frontMatter:function(){return r},metadata:function(){return c},toc:function(){return d}});var o=n(5893),s=n(1151);const r={title:"Context",sidebar_label:"Context"},i=void 0,c={id:"development/context",title:"Context",description:"A context object is provided with each call to the handler including the main methods of:",source:"@site/docs/development/context.md",sourceDirName:"development",slug:"/development/context",permalink:"/docs/development/context",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Context",sidebar_label:"Context"},sidebar:"docs",previous:{title:"Custom Handlers",permalink:"/docs/development/custom-handlers"},next:{title:"Storage",permalink:"/docs/development/storage"}},a={},d=[{value:"Customizing Context",id:"customizing-context",level:2}];function l(e){const t={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"A context object is provided with each call to the handler including the main methods of:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"public canHandleRequest(request:Request, context: Context): boolean"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"public async handleRequest(request:Request, context: Context): Promise<void>"})}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The context has access to the response builder, which is used to programmatically build responses, and also the user's long term and session storage."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"export interface Context<S extends Storage = Storage> {\n    /**\n     * Long term storage for the user.\n     */\n    storage: S;\n    /**\n     * The response builder.\n     */\n    response: AbstractResponseBuilder;\n    /**\n     * Session data. Gets deleted when session (id) changes)\n     */\n    session?: SessionStore;\n    /**\n     * Services available for the handlers\n     */\n    services: ContextServices;\n    /**\n     * Milliseconds left from the execution (NOTE: infinity if not executing in a lambda)\n     */\n    timeLeftInMillis?(): number;\n\n    // Note: Some fields omitted here for brevity\n}\n"})}),"\n",(0,o.jsx)(t.admonition,{type:"important",children:(0,o.jsxs)(t.p,{children:["Stentor will automatically save ",(0,o.jsx)(t.code,{children:"context.storage"})," to your UserStorageService after each transaction."]})}),"\n",(0,o.jsx)(t.h2,{id:"customizing-context",children:"Customizing Context"}),"\n",(0,o.jsx)(t.p,{children:"You may want to add your own data and services to the context for use throughout your custom handlers."}),"\n",(0,o.jsx)(t.p,{children:"First define your updated context.  It must extend the existing context object."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'import {  Context } from "stentor";\n\nexport interface CustomContext extends Context {\n    foo: number;\n}\n\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Next, implement the runtime hook ",(0,o.jsx)(t.code,{children:"postContextCreation"})," to modify your context before it is sent to a handler."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'\n// Note we are using CustomContext as the type for the second parameter\nconst postContextCreation = async (request: Request, context: CustomContext): Promise<{ request: Request, context: Context }> => {\n    // Make the modifications to the request and context\n    request.userId = "newID";\n    context.foo = 1\n    // Pass them back out\n    return { request, context };\n};\n\nexport const handler = new Assistant()\n    .withHooks({ postContextCreation })\n    .withUserStorage(new DynamoUserStorage())\n    .withHandlerService(studioService)\n    .withKnowledgeBaseService(studioService, {\n        // Intent ID for your fallback to determine if we call  KnowledgeBase\n        matchIntentId: "InputUnknown",\n        // For KnowledgeBase results we will generate a request with the following ID\n        setIntentId: "OCSearch"\n    })\n    .withHandlers({\n        QuestionAnsweringHandler: QuestionAnsweringHandler\n    })\n    .withChannels([Alexa(), Dialogflow(), LexConnect(), LexV2Channel(), Stentor(nlu)])\n    .lambda();\n\n'})}),"\n",(0,o.jsx)(t.p,{children:"Finally, update your handler method signatures to use CustomContext."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"\nexport class CustomContextHandler extends AbstractHandler {\n\n    // Use the CustomContext instead of the Context in the method signature \n    public async handleRequest(request: Request, context: CustomContext): Promise<void> {\n        // You now have access to the updated custom fields\n        context.response.say(`${request.userId} ${context.foo}`);\n\n        return;\n    }\n} \n\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1151:function(e,t,n){n.d(t,{Z:function(){return c},a:function(){return i}});var o=n(7294);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);