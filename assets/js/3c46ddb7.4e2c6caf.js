"use strict";(self.webpackChunkoc_studio_docs=self.webpackChunkoc_studio_docs||[]).push([[7910],{8086:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"development/context","title":"Context","description":"A context object is provided with each call to the handler including the main methods of:","source":"@site/docs/development/context.md","sourceDirName":"development","slug":"/development/context","permalink":"/docs/development/context","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Context","sidebar_label":"Context"},"sidebar":"docs","previous":{"title":"Custom Handlers","permalink":"/docs/development/custom-handlers"},"next":{"title":"Storage","permalink":"/docs/development/storage"}}');var s=n(4848),r=n(8453);const i={title:"Context",sidebar_label:"Context"},a=void 0,c={},l=[{value:"Customizing Context",id:"customizing-context",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.p,{children:"A context object is provided with each call to the handler including the main methods of:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"public canHandleRequest(request:Request, context: Context): boolean"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"public async handleRequest(request:Request, context: Context): Promise<void>"})}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The context has access to the response builder, which is used to programmatically build responses, and also the user's long term and session storage."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"export interface Context<S extends Storage = Storage> {\n    /**\n     * Long term storage for the user.\n     */\n    storage: S;\n    /**\n     * The response builder.\n     */\n    response: AbstractResponseBuilder;\n    /**\n     * Session data. Gets deleted when session (id) changes)\n     */\n    session?: SessionStore;\n    /**\n     * Services available for the handlers\n     */\n    services: ContextServices;\n    /**\n     * Milliseconds left from the execution (NOTE: infinity if not executing in a lambda)\n     */\n    timeLeftInMillis?(): number;\n\n    // Note: Some fields omitted here for brevity\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"important",children:(0,s.jsxs)(t.p,{children:["Stentor will automatically save ",(0,s.jsx)(t.code,{children:"context.storage"})," to your UserStorageService after each transaction."]})}),"\n",(0,s.jsx)(t.h2,{id:"customizing-context",children:"Customizing Context"}),"\n",(0,s.jsx)(t.p,{children:"You may want to add your own data and services to the context for use throughout your custom handlers."}),"\n",(0,s.jsx)(t.p,{children:"First define your updated context.  It must extend the existing context object."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import {  Context } from "stentor";\n\nexport interface CustomContext extends Context {\n    foo: number;\n}\n\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Next, implement the runtime hook ",(0,s.jsx)(t.code,{children:"postContextCreation"})," to modify your context before it is sent to a handler."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'\n// Note we are using CustomContext as the type for the second parameter\nconst postContextCreation = async (request: Request, context: CustomContext): Promise<{ request: Request, context: Context }> => {\n    // Make the modifications to the request and context\n    request.userId = "newID";\n    context.foo = 1\n    // Pass them back out\n    return { request, context };\n};\n\nexport const handler = new Assistant()\n    .withHooks({ postContextCreation })\n    .withUserStorage(new DynamoUserStorage())\n    .withHandlerService(studioService)\n    .withKnowledgeBaseService(studioService, {\n        // Intent ID for your fallback to determine if we call  KnowledgeBase\n        matchIntentId: "InputUnknown",\n        // For KnowledgeBase results we will generate a request with the following ID\n        setIntentId: "OCSearch"\n    })\n    .withHandlers({\n        QuestionAnsweringHandler: QuestionAnsweringHandler\n    })\n    .withChannels([Alexa(), Dialogflow(), LexConnect(), LexV2Channel(), Stentor(nlu)])\n    .lambda();\n\n'})}),"\n",(0,s.jsx)(t.p,{children:"Finally, update your handler method signatures to use CustomContext."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"\nexport class CustomContextHandler extends AbstractHandler {\n\n    // Use the CustomContext instead of the Context in the method signature \n    public async handleRequest(request: Request, context: CustomContext): Promise<void> {\n        // You now have access to the updated custom fields\n        context.response.say(`${request.userId} ${context.foo}`);\n\n        return;\n    }\n} \n\n"})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var o=n(6540);const s={},r=o.createContext(s);function i(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);