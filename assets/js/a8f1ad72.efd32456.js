"use strict";(self.webpackChunkoc_studio_docs=self.webpackChunkoc_studio_docs||[]).push([[1231],{5717:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"development/custom-handlers","title":"Custom Handlers","description":"The handler defines a single state of the dialog manager.  The dialog manger will take care of selecting it and instantiating it for you, you just need to focus on the custom logic and integrations within the handler.","source":"@site/docs/development/custom-handlers.md","sourceDirName":"development","slug":"/development/custom-handlers","permalink":"/docs/development/custom-handlers","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Custom Handlers"},"sidebar":"docs","previous":{"title":"Custom Application","permalink":"/docs/development/custom-application"},"next":{"title":"Context","permalink":"/docs/development/context"}}');var o=n(4848),s=n(8453);const i={title:"Custom Handlers"},a=void 0,d={},l=[{value:"Redirects and Forwards",id:"redirects-and-forwards",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.a,{href:"/docs/content/handlers",children:"handler"})," defines a single state of the ",(0,o.jsx)(t.a,{href:"/docs/dialog-manager/overview",children:"dialog manager"}),".  The dialog manger will take care of selecting it and instantiating it for you, you just need to focus on the custom logic and integrations within the handler."]}),"\n",(0,o.jsxs)(t.admonition,{type:"important",children:[(0,o.jsx)(t.p,{children:"You must both:"}),(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"tell the assistant application about the handler"}),"\n",(0,o.jsx)(t.li,{children:"update the handler type within OC Studio with your class name in order to leverage it."}),"\n"]})]}),"\n",(0,o.jsx)(t.p,{children:"Example Custom Handler File"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:'import { AbstractHandler, Context, keyFromRequest, Request } from "stentor";\n\n// 1. Rename to something that describes what the handler does like "SearchHandler"\nexport class CustomHandler extends AbstractHandler {\n\n    // 2. Define which requests the handler can handle\n    public canHandleRequest(request: Request, context: Context): boolean {\n\n        const key = keyFromRequest(request);\n\n        const handled: string[] = ["HelpIntent"];\n\n        if (handled.includes(key)) {\n            return true;\n        }\n\n        return super.canHandleRequest(request, context);\n    }\n\n    // The handleRequest is called \n    public async handleRequest(request: Request, context: Context): Promise<void> {\n        // 3. Write your custom logic\n        const key = keyFromRequest(request);\n\n        switch (key) {\n            case this.intentId:\n                // Kick off the flow\n                context.response.say(\'Hello world!\')\n                    .reprompt("The reprompt is used on voice channels when the user doesn\'t respond.")\n                    .withCard({\n                        type: "CARD",\n                        title: "Card",\n                        content: "This is an example of a card"\n                    });\n                // Exit from the flow\n                return;\n            case \'HelpIntent\':\n                // Provide contextual help \n                context.response.say(\'This is handler specific help that is returned.\');\n                // Exit from the flow\n                return;\n            default:\n            // Let it fall through to the super\n            // \ud83d\udc47\n        }\n\n        // 4. Let remaining requests fall through to the super\n        //    It is not recommended to remove this\n        return super.handleRequest(request, context);\n    }\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:"You then must register the custom handler with the dialog manager in the application builder:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"export const handler = new Assistant()\n    .withHandlers({\n        CustomHandler\n    })\n    .withChannels([Alexa(), Dialogflow()])\n    .lambda();\n"})}),"\n",(0,o.jsxs)(t.admonition,{type:"important",children:[(0,o.jsxs)(t.p,{children:["If you are using a minifier that changes the class names then instead of using the shorthand notation when the key and value are the same like in the above example, you must use the longer ",(0,o.jsx)(t.code,{children:"CustomHandler: CustomerHandler"})]}),(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:"    .withHandlers({\n        CustomHandler: CustomHandler\n    })\n"})})]}),"\n",(0,o.jsx)(t.p,{children:"Once you have registered it with the application, you must set the type in Studio for the handlers that will use it."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"img",src:n(1546).A+"",width:"1582",height:"804"})}),"\n",(0,o.jsx)(t.h2,{id:"redirects-and-forwards",children:"Redirects and Forwards"}),"\n",(0,o.jsxs)(t.p,{children:["In addition to defining the content that is returned, you can also programmatically control ",(0,o.jsx)(t.a,{href:"/docs/content/handlers#redirects--forwards",children:"redirect and forwarding"})," paths."]}),"\n",(0,o.jsx)(t.p,{children:"Add the either or both of the following to your custom handler."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-ts",children:'    public async redirectingPathForRequest(request: Request, context: Context<Storage>): Promise<ExecutablePath> {\n\n        if (true /* replace with your logic to dermine need to redirect */) {\n            return {\n                type: "START",\n                intentId: "NewIntentId"\n            };\n        }\n\n        return super.redirectingPathForRequest(request, context);\n    }\n\n    public async forwardingPathForRequest(request: Request, context: Context<Storage>): Promise<ExecutablePath> {\n        if (true /* replace with your logic to dermine need to forward */) {\n            return {\n                type: "START",\n                intentId: "NewIntentId"\n            };\n        }\n\n        return super.forwardingPathForRequest(request, context);\n    }\n'})}),"\n",(0,o.jsxs)(t.p,{children:["If you need to redirect or forward, return an object, of type ExecutablePath, that contains the ID (",(0,o.jsx)(t.code,{children:"intentId"}),") of the handler you will be forwarding to.  You could potentially just return ",(0,o.jsx)(t.code,{children:"undefined"})," if you are not changing handlers however there is benefit in calling the super methods.  If you fall through to the supers then you can also define the behavior inside OC Studio's GUI, which gives you more flexibility to modify the behavior without development."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1546:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/set-custom-type-543bbbe7921f7940b997615d8f7952eb.gif"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var r=n(6540);const o={},s=r.createContext(o);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);